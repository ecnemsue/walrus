"use strict";(globalThis.webpackChunkwalrus_docusaurus=globalThis.webpackChunkwalrus_docusaurus||[]).push([[1220],{3157:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"design/architecture","title":"Basic Architecture and Security Assumptions","description":"Overview of Walrus system architecture including users, storage nodes, aggregators, and security assumptions for Byzantine fault tolerance.","source":"@site/../content/design/architecture.mdx","sourceDirName":"design","slug":"/design/architecture","permalink":"/docs/design/architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/MystenLabs/walrus/tree/main/docs/../content/design/architecture.mdx","tags":[],"version":"current","frontMatter":{"title":"Basic Architecture and Security Assumptions","description":"Overview of Walrus system architecture including users, storage nodes, aggregators, and security assumptions for Byzantine fault tolerance.","keywords":["walrus","architecture","storage nodes","shards","byzantine fault tolerance","aggregators","publishers","clients","security assumptions"]},"sidebar":"designSidebar","previous":{"title":"System Overview","permalink":"/docs/design/overview"},"next":{"title":"Encoding, Overheads, and Verification","permalink":"/docs/design/encoding"}}');var r=t(2714),o=t(8885);const a={title:"Basic Architecture and Security Assumptions",description:"Overview of Walrus system architecture including users, storage nodes, aggregators, and security assumptions for Byzantine fault tolerance.",keywords:["walrus","architecture","storage nodes","shards","byzantine fault tolerance","aggregators","publishers","clients","security assumptions"]},i=void 0,c={},l=[];function d(e){const s={a:"a",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{Term:t}=s;return t||function(e,s){throw new Error("Expected "+(s?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Term",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(s.p,{children:"The key actors in the Walrus architecture are the following:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Users"})," through ",(0,r.jsx)(s.strong,{children:"clients"})," want to store and read ",(0,r.jsx)(s.strong,{children:(0,r.jsx)(t,{lookup:"Blob",children:"blobs"})})," identified by their ",(0,r.jsx)(s.strong,{children:(0,r.jsx)(t,{lookup:"Blob ID",children:"blob ID"})}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["These actors are ready to pay for service\nwhen it comes to writes and non-best-effort reads. Users also want to prove\nthe ",(0,r.jsx)(s.strong,{children:"availability"})," of a ","blob"," to third parties without the cost of sending or receiving the full\n","blob","."]}),"\n",(0,r.jsxs)(s.p,{children:["Users might be malicious in various ways: they might not want to pay for services, prove the\navailability of unavailable ","blobs",", modify/delete ","blobs"," without authorization, try to\nexhaust resources of ",(0,r.jsx)(t,{lookup:"Storage node",children:"storage nodes"}),", and so on."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Storage nodes"})," hold one or many ",(0,r.jsx)(s.strong,{children:"shards"})," within a ",(0,r.jsx)(s.strong,{children:(0,r.jsx)(t,{lookup:"Storage epoch",children:"storage epoch"})}),"."]}),"\n",(0,r.jsxs)(s.p,{children:["Each ","blob"," is erasure-encoded into many ",(0,r.jsx)(s.strong,{children:"slivers"}),". Slivers from each stored ","blob"," become part\nof all shards. A ",(0,r.jsx)(t,{lookup:"Shard",children:"shard"})," at any ","storage epoch"," is associated with a ","storage node"," that actually stores\nall slivers of the ","shard"," and is ready to serve them."]}),"\n",(0,r.jsxs)(s.p,{children:["A Sui smart contract controls the assignment of shards to ","storage nodes"," within\n",(0,r.jsx)(s.strong,{children:"storage epochs"})," (2 weeks on Mainnet), and Walrus assumes that more than 2/3 of the\nshards are managed by correct ","storage nodes"," within each ","storage epoch",". This means that Walrus must\ntolerate up to 1/3 of the shards managed by Byzantine ","storage nodes"," (approximately 1/3 of the\n","storage nodes"," being Byzantine) within each ","storage epoch"," and across storage epochs."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:["All clients and ","storage nodes"," operate a blockchain ",(0,r.jsx)(t,{lookup:"Client",children:"client"})," (specifically on Sui), and mediate\npayments, resources (space), mapping of shards to ","storage nodes",", and metadata through blockchain\nsmart contracts. Users interact with the blockchain to acquire storage resources and upload\ncertificates for stored ","blobs",". ","Storage nodes"," listen to the blockchain events to coordinate\ntheir operations."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Walrus supports any additional number of optional infrastructure actors that can operate in a\npermissionless way:"}),"\n",(0,r.jsxs)(s.ul,{children:["\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Aggregators"})," are clients that reconstruct ","blobs"," from slivers and make them available to users\nover traditional web2 technologies (such as HTTP). They are optional in that end users may\nreconstruct ","blobs"," directly or run a local ",(0,r.jsx)(t,{lookup:"Aggregator",children:"aggregator"})," to perform Walrus reads over web2\ntechnologies locally."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Caches"})," are aggregators with additional caching functionality to decrease latency and reduce\nload on ","storage nodes",". Such ",(0,r.jsx)(t,{lookup:"Cache",children:"cache"})," infrastructures may also act as CDNs, split the cost of ","blob",(0,r.jsx)(t,{lookup:"Reconstruction",children:"reconstruction"})," over many requests, be better connected, and so on. A ","client"," can always verify that\nreads from such infrastructures are correct."]}),"\n"]}),"\n",(0,r.jsxs)(s.li,{children:["\n",(0,r.jsxs)(s.p,{children:[(0,r.jsx)(s.strong,{children:"Publishers"})," are clients that help end users store a ","blob"," using web2 technologies,\nusing less bandwidth and custom logic."]}),"\n",(0,r.jsxs)(s.p,{children:["In effect, they receive the ","blob"," to be published over traditional web2 protocols (like HTTP) and\nrun the Walrus store protocol on the ",(0,r.jsx)(t,{lookup:"User",children:"end user"}),"'s behalf. This includes encoding the ","blob"," into\nslivers, distributing the slivers to ","storage nodes",", collecting storage-node signatures and\naggregating them into a certificate, as well as all other on-chain actions."]}),"\n",(0,r.jsxs)(s.p,{children:["They are optional in that a ","user"," can directly interact with Sui and\nthe ","storage nodes"," to store ","blobs",". An ","end user"," can always verify that a ",(0,r.jsx)(t,{lookup:"Publisher",children:"publisher"}),"\nperformed their duties correctly by checking that an event associated with the\n",(0,r.jsx)(s.strong,{children:(0,r.jsx)(s.a,{href:"/docs/design/properties",children:"point of availability"})})," for the ","blob"," exists on chain\nand then either performing a read to see if Walrus returns the ","blob"," or encoding the ","blob","\nand comparing the result to the ","blob ID"," in the certificate."]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(s.p,{children:"Aggregators, publishers, and end users are not considered trusted components of the system, and they\nmight deviate from the protocol arbitrarily. However, some of the security properties of Walrus only\nhold for honest end users that use honest intermediaries (caches and publishers). Walrus provides a\nmeans for end users to audit the correct operation of both caches and publishers."})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,r.jsx)(s,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8885:(e,s,t)=>{t.d(s,{R:()=>a,x:()=>i});var n=t(9378);const r={},o=n.createContext(r);function a(e){const s=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),n.createElement(o.Provider,{value:s},e.children)}}}]);
"use strict";(globalThis.webpackChunkwalrus_docusaurus=globalThis.webpackChunkwalrus_docusaurus||[]).push([[4750],{8182:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"operator-guide/auth-publisher","title":"The Authenticated Publisher","description":"Guide to setting up and using authenticated Walrus publishers with JWT authentication for controlled blob storage access.","source":"@site/../content/operator-guide/auth-publisher.mdx","sourceDirName":"operator-guide","slug":"/operator-guide/auth-publisher","permalink":"/docs/operator-guide/auth-publisher","draft":false,"unlisted":false,"editUrl":"https://github.com/MystenLabs/walrus/tree/main/docs/../content/operator-guide/auth-publisher.mdx","tags":[],"version":"current","frontMatter":{"title":"The Authenticated Publisher","description":"Guide to setting up and using authenticated Walrus publishers with JWT authentication for controlled blob storage access.","keywords":["walrus","authenticated publisher","jwt","authentication","access control","mainnet","security","token verification"]},"sidebar":"docsSidebar","previous":{"title":"Operating an Aggregator","permalink":"/docs/operator-guide/aggregator"},"next":{"title":"Operating a Storage Node","permalink":"/docs/operator-guide/storage-node"}}');var s=n(2714),o=n(8885);const r={title:"The Authenticated Publisher",description:"Guide to setting up and using authenticated Walrus publishers with JWT authentication for controlled blob storage access.",keywords:["walrus","authenticated publisher","jwt","authentication","access control","mainnet","security","token verification"]},a=void 0,h={},l=[{value:"Overview",id:"overview",level:2},{value:"Request Authentication Flow",id:"request-authentication-flow",level:3},{value:"Publisher setup",id:"publisher-setup",level:2},{value:"The JWT Decode Secret",id:"the-jwt-decode-secret",level:3},{value:"Authentication Algorithm",id:"authentication-algorithm",level:3},{value:"JWT Expiration",id:"jwt-expiration",level:3},{value:"Upload parameters verification",id:"upload-parameters-verification",level:3},{value:"Replay-suppression configuration",id:"replay-suppression-configuration",level:3},{value:"Details on the JWT",id:"details-on-the-jwt",level:2},{value:"JWT Fields",id:"jwt-fields",level:3},{value:"Mandatory fields",id:"mandatory-fields",level:4},{value:"Optional fields",id:"optional-fields",level:4},{value:"Creating a Valid JWT in the Backend",id:"creating-a-valid-jwt-in-the-backend",level:3},{value:"Rust",id:"rust",level:4}];function c(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{Term:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Term",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["We now describe the authenticated ",(0,s.jsx)(n,{lookup:"Publisher",children:"publisher"}),", which requires the HTTP request to store a ",(0,s.jsx)(n,{lookup:"Blob",children:"blob"})," to be\nauthenticated. Such an authenticated ","publisher"," can be used as a building block for services that\nrequire storing over HTTP on Walrus ",(0,s.jsx)(t.code,{children:"mainnet"}),', where an "open" ',"publisher"," is undesirable (because of\nthe ",(0,s.jsx)(t.code,{children:"SUI"})," and ",(0,s.jsx)(t.code,{children:"WAL"})," cost of publishing to Walrus)."]}),"\n",(0,s.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsxs)(t.p,{children:["The Walrus ","Publisher"," can be configured to require a JWT (JSON web Token) with each HTTP request, for\n",(0,s.jsx)(n,{lookup:"User",children:"user"})," authentication. The authentication system ensures that only authorized clients can store ","blobs","\nand allows for fine-grained control over storage parameters through JWT claims."]}),"\n",(0,s.jsx)(t.p,{children:"The authenticated publishing flow occurs, at a high level, as follows:"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:["Publisher"," setup"]}),": The ","publisher"," operator:","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Funds the ","publisher","'s wallet with sufficient ",(0,s.jsx)(t.code,{children:"SUI"})," and ",(0,s.jsx)(t.code,{children:"WAL"}),";"]}),"\n",(0,s.jsxs)(t.li,{children:["Configures the ","publisher"," to only accept authenticated requests. This entails setting the\nalgorithm to authenticate JWTs, the expiration time for JWTs, and the JWT authentication\nsecret."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Authentication channel setup"}),": The ","publisher"," operator sets up a channel through which users\ncan obtain the JWT tokens. This step can be performed in any way that produces a valid JWT, and\nis not provided in this implementation."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsxs)(t.strong,{children:[(0,s.jsx)(n,{lookup:"Client",children:"Client"})," authentication"]}),": The ","client"," obtains a JWT token from the channel set up in the previous\nstep. The JWT token can specify Walrus-relevant constraints, such as the maximum number of epochs\nthe JWT can be used to store for, and the maximum size of the ","blobs"," being stored."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Publish request"}),": The ","client"," requests to store a ","blob"," using the ","publisher",". This is done\nthrough an HTTP PUT request containing the JWT in an Authorization Bearer HTTP header."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Store to Walrus"}),": The ","publisher"," checks the JWT, and checks that the store request is compliant\nwith the constraints specified in the JWT (e.g., the ","blob"," being stored is smaller than the\nauthorized max size)."]}),"\n",(0,s.jsxs)(t.li,{children:["(Optional) ",(0,s.jsx)(t.strong,{children:"Asset return:"}),": If so specified, the ","publisher"," returns the newly-created ",(0,s.jsx)(t.code,{children:"Blob"}),"\nobject to the Sui Address set in the request."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"request-authentication-flow",children:"Request Authentication Flow"}),"\n",(0,s.jsxs)(t.p,{children:["We now provide an example of how the authenticated ","publisher"," can be used in a webapp that allows\nusers to upload files to Walrus through a web frontend. This is especially useful if the users are\n",(0,s.jsx)(t.em,{children:"not"})," required to have a wallet, and therefore cannot store ","blobs"," to Walrus on their own."]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["The ","user"," connects to the webapp, authenticates (e.g., through name and password, as they have no\nwallet)."]}),"\n",(0,s.jsxs)(t.li,{children:["The ","user"," uploads the file it wants to store, and selects the number of epochs for which it would\nlike to store it."]}),"\n",(0,s.jsx)(t.li,{children:"The webapp frontend sends information on the size of the file and the number of epochs to the\nbackend."}),"\n",(0,s.jsxs)(t.li,{children:["With this information, the backend computes if the ","user"," is authorized to store the given amount of\ndata for the selected number of epochs, and possibly reduces the ","user"," quota. This accounting can\nbe done locally, but also directly on Sui. Importantly, at this point the backend can also check\nthe cost of the upload (in terms of SUI and ",(0,s.jsx)(n,{lookup:"WAL",children:"WAL"}),"), and check if it is within the ","user","'s budget."]}),"\n",(0,s.jsxs)(t.li,{children:["If the ","user"," is authorized to store, the backend returns a JWT token with the size and epoch limits\nto the frontend."]}),"\n",(0,s.jsxs)(t.li,{children:["The frontend sends the file to the ","publisher"," via a ",(0,s.jsx)(t.code,{children:"PUT"})," request, setting the JWT in the\nAuthorization header as a Bearer token."]}),"\n",(0,s.jsxs)(t.li,{children:["Upon receipt, the ","publisher"," verifies:","\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:"The token signature using the configured secret;"}),"\n",(0,s.jsx)(t.li,{children:"Token expiration;"}),"\n",(0,s.jsx)(t.li,{children:"Token uniqueness (prevents replay attacks);"}),"\n",(0,s.jsx)(t.li,{children:"Upload parameters against claims (if enabled)."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(t.li,{children:["If all checks succeed, the ","publisher"," stores the file on Walrus."]}),"\n",(0,s.jsxs)(t.li,{children:["If set, the ","publisher"," finally returns the created ",(0,s.jsx)(t.code,{children:"Blob"})," object to the address specified by the\n","user","."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'One important note here is that the JWT token itself is a "single use" token, and should not be used\nfor accounting purposes. I.e., one token can be used to store only one file, and after that the\ntoken is rejected by the replay suppression system.'}),"\n",(0,s.jsxs)(t.h2,{id:"publisher-setup",children:["Publisher"," setup"]}),"\n",(0,s.jsxs)(t.p,{children:["The ","publisher"," is configured at startup using the following command line arguments:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"--jwt-decode-secret"}),": The secret key used to verify JWT signatures. If set, the ","publisher"," will\nonly store ","blobs"," with valid JWTs."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"--jwt-algorithm"}),": The algorithm used for JWT verification (defaults to HMAC)."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"--jwt-expiring-sec"}),": Duration in seconds after which the JWT is considered expired."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"--jwt-verify-upload"}),": Enable verification of upload parameters against JWT claims."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Additional details follow."}),"\n",(0,s.jsx)(t.h3,{id:"the-jwt-decode-secret",children:"The JWT Decode Secret"}),"\n",(0,s.jsxs)(t.p,{children:["The secret can be hex string, starting with ",(0,s.jsx)(t.code,{children:"0x"}),". If this parameter is not specified, the\nauthentication will be disabled."]}),"\n",(0,s.jsxs)(t.p,{children:["All JWT tokens are expected to have the ",(0,s.jsx)(t.code,{children:"jti"})," (JWT ID) set in the claim to a unique value. The JWT\nis used for replay suppression, i.e., to avoid malicious users storing multiple times using the same\nJWT. Therefore, the JWT creator must ensure that this value is unique among all requests to the\n","publisher",". We recommend using large nonces to avoid collisions."]}),"\n",(0,s.jsx)(t.h3,{id:"authentication-algorithm",children:"Authentication Algorithm"}),"\n",(0,s.jsx)(t.p,{children:'The following algorithms are supported: "HS256", "HS384", "HS512", "ES256", "ES384", "RS256",\n"RS384", "PS256", "PS384", "PS512", "RS512", "EdDSA". The default JWT authentication algorithm will\nbe HS256.'}),"\n",(0,s.jsx)(t.h3,{id:"jwt-expiration",children:"JWT Expiration"}),"\n",(0,s.jsxs)(t.p,{children:["If the parameter is set and greater than 0, the ","publisher",' will check if the JWT token is expired\nbased on the "issued at" (',(0,s.jsx)(t.code,{children:"iat"}),") value in the JWT token."]}),"\n",(0,s.jsx)(t.h3,{id:"upload-parameters-verification",children:"Upload parameters verification"}),"\n",(0,s.jsxs)(t.p,{children:["If set, the ","publisher"," will verify that the requested upload matches the claims in the JWT. This\n",(0,s.jsx)(t.em,{children:"does not"})," enable or disable the cryptographic authentication of the JWT; it just enables or\ndisables the checks that ensure the contents of the JWT claim match the requested ","blob"," upload."]}),"\n",(0,s.jsxs)(t.p,{children:["Specifically, the ","publisher"," will:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Verify that the number of ",(0,s.jsx)(t.code,{children:"epochs"})," in query is the the same as ",(0,s.jsx)(t.code,{children:"epochs"})," in the JWT, if present;"]}),"\n",(0,s.jsxs)(t.li,{children:["Verify that the ",(0,s.jsx)(t.code,{children:"send_object_to"})," field in the query is the same as the ",(0,s.jsx)(t.code,{children:"send_object_to"})," in the\nJWT, if present;"]}),"\n",(0,s.jsx)(t.li,{children:"Verify the size of uploaded file;"}),"\n",(0,s.jsxs)(t.li,{children:["Verify the uniqueness of the ",(0,s.jsx)(t.code,{children:"jti"})," claim."]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Disabiling the parameter verification may be useful in case the source of the store requests is\ntrusted, but the ","publisher"," mayy be contacted by untrusted sources. In that case, the authentication\nof the JWT is necessary, but not the verification of the upload parameters."]}),"\n",(0,s.jsx)(t.h3,{id:"replay-suppression-configuration",children:"Replay-suppression configuration"}),"\n",(0,s.jsxs)(t.p,{children:["As mentioned above, the ","publisher"," supports replay suppression to avoid the malicious reuse of JWT\ntokens."]}),"\n",(0,s.jsx)(t.p,{children:"The replay suppression supports the following configuration parameters:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"--jwt-cache-size"}),": The maximum size of the ","publisher","'s JWT ",(0,s.jsx)(n,{lookup:"Cache",children:"cache"}),", where the ",(0,s.jsx)(t.code,{children:"jti"}),' JWT IDs of the\n"used" JWTs are kept until their expiration. This is a hard upperbound on the number of entries in\nthe ',"cache",", after which additional requests to store are rejected. This hard bound is introduced to\navoid DoS attacks on the ","publisher"," through the ","cache","."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"--jwt-cache-refresh-interval"}),": The interval (in seconds) after which the ","cache"," is refreshed, and\nexpired JWTs are removed (possibly creating space for additional JWTs to be inserted)."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"details-on-the-jwt",children:"Details on the JWT"}),"\n",(0,s.jsx)(t.h3,{id:"jwt-fields",children:"JWT Fields"}),"\n",(0,s.jsxs)(t.p,{children:["The current authenticated ","publisher"," implementation does not provide a way to generate the JWTs and\ndistribute them to the clients. These can be generated with any tool (examples on how to create a\nJWT are given in the next section), as long as they respect the following constraints."]}),"\n",(0,s.jsx)(t.h4,{id:"mandatory-fields",children:"Mandatory fields"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"exp"})," (Expiration): timestamp when the token expires;"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"jti"})," (JWT ID): unique identifier for the token to prevent replay attacks;"]}),"\n"]}),"\n",(0,s.jsx)(t.h4,{id:"optional-fields",children:"Optional fields"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"iat"})," (Issued At): Optional timestamp when the token was issued;"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"send_object_to"}),": Optional Sui address where the newly-created ",(0,s.jsx)(t.code,{children:"Blob"})," object should be sent;"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"epochs"}),": Optional exact number of epochs the ","blob"," should be stored for"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"max_epochs"}),": Optional maximum number of epochs the ","blob"," can be stored for"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"max_size"}),": Optional maximum size of the ","blob"," in bytes"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"size"}),": Optional exact size of the ","blob"," in bytes"]}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["Note: The ",(0,s.jsx)(t.code,{children:"epochs"})," and ",(0,s.jsx)(t.code,{children:"max_epochs"})," claims cannot be used together, and neither can ",(0,s.jsx)(t.code,{children:"size"})," and\n",(0,s.jsx)(t.code,{children:"max_size"}),". Using both in either case will result in token rejection."]}),"\n",(0,s.jsxs)(t.p,{children:["Importanlty, the JWT (at the moment) can only encode information on the size and epochs of the ","blob",'\nto store, and not on the "amount of SUI and ',"WAL",'" the ',"user"," is allowed to consume. This should be done\non the backend, before issuing the JWT."]}),"\n",(0,s.jsx)(t.h3,{id:"creating-a-valid-jwt-in-the-backend",children:"Creating a Valid JWT in the Backend"}),"\n",(0,s.jsxs)(t.p,{children:["We provide here a few examples on how to create JWTs that can be consumed by the authenticated\n","publisher","."]}),"\n",(0,s.jsx)(t.h4,{id:"rust",children:"Rust"}),"\n",(0,s.jsxs)(t.p,{children:["In Rust, the ",(0,s.jsx)(t.a,{href:"https://docs.rs/jsonwebtoken/latest/jsonwebtoken/",children:(0,s.jsx)(t.code,{children:"jsonwebtoken"})})," crate can be\nused to create JWTs."]}),"\n",(0,s.jsxs)(t.p,{children:["In our code, we use the following struct to deserialize the incoming tokens in the ","publisher"," (see\nthe the\n",(0,s.jsx)(t.a,{href:"https://github.com/MystenLabs/walrus/blob/main/crates/walrus-service/src/client/daemon/auth.rs",children:"code"}),"\nfor the complete version)."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:"pub struct Claim {\n    pub iat: Option<i64>,\n    pub exp: i64,\n    pub jti: String,\n    pub send_object_to: Option<SuiAddress>,\n    pub epochs: Option<u32>,\n    pub max_epochs: Option<u32>,\n    pub size: Option<u64>,\n    pub max_size: Option<u64>,\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"The same struct can be used to create and then encode valid tokens in Rust. This will be something\nalong the lines of:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-rust",children:'use jsonwebtoken::{encode, Algorithm, EncodingKey, Header};\n\n...\n\nlet encoding_key = EncodingKey::from_secret("my_secret".as_bytes());\nlet claim = Claim { /* set here the parameters for the Claim struct above */ };\nlet jwt = encode(&Header::default(), &claim, &encode_key).expect("a valid claim and key");\n'})})]})}function d(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8885:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(9378);const s={},o=i.createContext(s);function r(e){const t=i.useContext(o);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);